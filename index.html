<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>PentathlonScore – Results</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { color-scheme: light dark; }

    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 0;
      padding: 0;
      background: #f3f4f6;
      color: #111827;
    }

    header {
      background: #111827;
      color: #f9fafb;
      padding: 10px 16px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
    }

    .logo {
      font-weight: 600;
      font-size: 1.1rem;
      text-decoration: none;
      color: #f9fafb;
    }

    nav {
      display: flex;
      gap: 12px;
      margin-top: 6px;
    }

    .nav-link {
      color: #e5e7eb;
      text-decoration: none;
      font-size: 0.9rem;
      padding: 4px 8px;
      border-radius: 4px;
    }

    .nav-link:hover { background: #1f2937; }

    .nav-link.active {
      background: #4f46e5;
      color: #f9fafb;
    }

    main {
      max-width: 1100px;
      margin: 16px auto 40px;
      padding: 0 12px;
    }

    .card {
      background: white;
      border-radius: 8px;
      padding: 14px 14px 16px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.06);
      margin-bottom: 16px;
    }

    h1 { font-size: 1.4rem; margin: 0 0 4px; }
    h2 { font-size: 1.1rem; margin: 0 0 4px; }

    p {
      margin: 4px 0;
      font-size: 0.9rem;
      color: #4b5563;
    }

    .note { font-size: 0.85rem; color: #6b7280; }

    label {
      display: block;
      font-size: 0.85rem;
      margin-bottom: 4px;
      color: #374151;
    }

    select {
      width: 100%;
      max-width: 360px;
      padding: 6px 8px;
      font-size: 0.9rem;
      border-radius: 4px;
      border: 1px solid #d1d5db;
    }

    select:focus {
      outline: none;
      border-color: #6366f1;
      box-shadow: 0 0 0 1px #6366f1;
    }

    .select-grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px;
      margin-top: 10px;
    }

    @media (min-width: 720px) {
      .select-grid {
        grid-template-columns: 1fr 1fr;
        align-items: end;
      }
    }

    .message { font-size: 0.85rem; margin-top: 6px; }
    .message.error { color: #b91c1c; }
    .message.info { color: #6b7280; }

    .comp-meta { font-size: 0.85rem; color: #4b5563; margin-top: 8px; }

    .pill {
      display: inline-block;
      padding: 2px 6px;
      font-size: 0.75rem;
      border-radius: 999px;
      background: #e5e7eb;
      color: #374151;
      margin-right: 4px;
    }

    .pill.status-live { background: #dcfce7; color: #166534; }
    .pill.status-finished { background: #fee2e2; color: #991b1b; }

    .division-jump-container {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 10px;
      margin-bottom: 4px;
    }

    .division-jump-btn {
      border: 1px solid #d1d5db;
      background: #f9fafb;
      border-radius: 999px;
      padding: 4px 10px;
      font-size: 0.8rem;
      cursor: pointer;
      color: #111827;
    }

    .division-jump-btn:hover { background: #e5e7eb; }

    .print-btn {
      margin-top: 8px;
      padding: 6px 10px;
      font-size: 0.85rem;
      border-radius: 4px;
      border: none;
      background: #4f46e5;
      color: white;
      cursor: pointer;
    }

    .print-btn:disabled { opacity: 0.5; cursor: default; }
    .print-btn:not(:disabled):hover { background: #4338ca; }

    .division-header {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 8px;
      margin-bottom: 4px;
    }

    .division-tags { font-size: 0.8rem; color: #6b7280; }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.85rem;
      margin-top: 6px;
    }

    th, td {
      padding: 6px 8px;
      border-bottom: 1px solid #e5e7eb;
      white-space: nowrap;
      vertical-align: middle;
    }

    th {
      background: #f9fafb;
      font-weight: 600;
    }

    /* Column alignment */
    th:first-child, td:first-child { text-align: center; }
    th:nth-child(2), td:nth-child(2) { text-align: left; }
    th:not(:first-child):not(:nth-child(2)),
    td:not(:first-child):not(:nth-child(2)) { text-align: right; }

    tr:nth-child(even) td { background: #f9fafb; }

    .rank-cell {
      text-align: center;
      font-weight: 600;
      width: 60px;
    }

    .name-cell {
      font-weight: 500;
      max-width: 190px; /* narrowed slightly to make room */
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .noc-cell { font-size: 0.8rem; color: #6b7280; }

    /* Discipline cell two-line layout */
    td.disc-cell, th.disc-head {
      text-align: center !important;
    }

    .disc-wrap {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      line-height: 1.1;
      font-variant-numeric: tabular-nums;
    }

    .disc-top {
      font-size: 0.82rem;
      color: #111827;
    }

    .disc-bottom {
      margin-top: 2px;
      font-size: 0.85rem;
      font-weight: 600;
      color: #111827;
    }

    .handicap-cell { font-variant-numeric: tabular-nums; }

    @media (max-width: 640px) {
      th, td { padding: 4px 6px; font-size: 0.8rem; }
      .division-header { flex-direction: column; align-items: flex-start; }
      .name-cell { max-width: 140px; }
    }

    @media print {
      header { display: none; }
      body { background: #ffffff; }
      main { max-width: none; margin: 0; padding: 0; }
      .card { box-shadow: none; border-radius: 0; margin: 0 0 8px; }
      #selectors-card .note,
      #selectors-card select,
      #competition-message,
      #division-jump-container,
      .print-btn { display: none !important; }
    }
  </style>
</head>
<body>
  <header>
    <a href="/" class="logo">PentathlonScore</a>
    <nav>
      <a href="/" class="nav-link active">Home</a>
      <a href="/admin-login.html" class="nav-link">Admin</a>
    </nav>
  </header>

  <main>
    <div class="card" id="selectors-card">
      <h1>Results</h1>
      <p class="note">Select a competition to view division leaderboards. Live competitions update as the admin enters results.</p>

      <div class="select-grid">
        <div>
          <label for="current-competition-select">Current Competition</label>
          <select id="current-competition-select">
            <option value="">Select a live competition</option>
          </select>
        </div>

        <div>
          <label for="past-competition-select">Past Competitions</label>
          <select id="past-competition-select">
            <option value="">Select a finished competition</option>
          </select>
        </div>
      </div>

      <div id="competition-message" class="message info"></div>
      <div id="competition-meta" class="comp-meta"></div>

      <div id="division-jump-container" class="division-jump-container"></div>

      <button type="button" id="print-btn" class="print-btn" disabled style="display:none;">
        Print Results
      </button>
    </div>

    <div id="leaderboard-container"></div>
  </main>

  <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
  <script>
    const SUPABASE_URL = "https://cbwifmgrekugoljcaqoh.supabase.co";
    const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImNid2lmbWdyZWt1Z29samNhcW9oIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQ3MDcxODYsImV4cCI6MjA4MDI4MzE4Nn0.Rp5MCWYQL9SxbnBEJ7e76gbbd95qsStaLE2Hkhpn47g";

    const { createClient } = window.supabase;
    const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    const currentSelect = document.getElementById("current-competition-select");
    const pastSelect = document.getElementById("past-competition-select");
    const competitionMessage = document.getElementById("competition-message");
    const competitionMeta = document.getElementById("competition-meta");
    const divisionJumpContainer = document.getElementById("division-jump-container");
    const leaderboardContainer = document.getElementById("leaderboard-container");
    const printBtn = document.getElementById("print-btn");

    let liveCompetitions = [];
    let finishedCompetitions = [];
    let activeCompetition = null;

    const SPECIAL_WORST = new Set(["DNS", "DNF", "DSQ", "EL"]);

    function setCompetitionMessage(text, type = "info") {
      competitionMessage.textContent = text || "";
      competitionMessage.className = "message " + type;
    }

    function formatStatusPill(status) {
      const s = (status || "").toLowerCase();
      let cls = "pill";
      if (s === "live") cls += " status-live";
      else if (s === "finished") cls += " status-finished";
      return `<span class="${cls}">${s || ""}</span>`;
    }

    function formatDateRange(start, end) {
      if (!start && !end) return "";
      if (start && !end) return start;
      if (!start && end) return end;
      if (start === end) return start;
      return `${start} – ${end}`;
    }

    function formatHandicap(seconds) {
      if (seconds == null || isNaN(seconds)) return "";
      const total = Math.round(Number(seconds));
      const sign = total < 0 ? "-" : "";
      const abs = Math.abs(total);
      const m = Math.floor(abs / 60);
      const s = abs % 60;
      const sStr = s < 10 ? "0" + s : "" + s;
      return sign + m + ":" + sStr;
    }

    function parseTimeToSeconds(str) {
      if (!str) return null;
      const s = String(str).trim();
      if (!s) return null;

      const upper = s.toUpperCase();
      if (SPECIAL_WORST.has(upper)) return null; // handled as "worst" via special flag

      // seconds only
      if (/^\d+(\.\d+)?$/.test(s)) return parseFloat(s);

      // M:SS.xx
      const parts = s.split(":");
      if (parts.length === 2) {
        const mins = parseFloat(parts[0]);
        const secs = parseFloat(parts[1]);
        if (isNaN(mins) || isNaN(secs)) return null;
        return mins * 60 + secs;
      }

      return null;
    }

    function parseFenceVictories(str) {
      if (!str) return null;
      const s = String(str).trim();
      if (!s) return null;

      const upper = s.toUpperCase();
      if (SPECIAL_WORST.has(upper)) return null; // handled as "worst"

      // e.g., 18V 15D
      const regex = /(\d+)\s*[Vv]\b/;
      const m = s.match(regex);
      if (m) {
        const v = parseInt(m[1], 10);
        return isNaN(v) ? null : v;
      }

      // allow bare number = victories
      if (/^\d+$/.test(s)) return parseInt(s, 10);

      return null;
    }

    /**
     * Compute discipline places (1,1,3...) based on raw performance.
     * Only assigns a place if raw is present (including DNS/DNF/DSQ/EL).
     * Special codes are treated as worst and tied for last.
     */
    function computeDisciplinePlaces(rows, discipline) {
      // Create score objects for only rows with raw entered
      const scored = [];

      for (const r of rows) {
        const raw = (r[discipline]?.raw || "").trim();
        if (!raw) continue;

        const upper = raw.toUpperCase();
        const isSpecialWorst = SPECIAL_WORST.has(upper);

        let metric = null;

        if (!isSpecialWorst) {
          if (discipline === "fence") {
            metric = parseFenceVictories(raw); // higher better
          } else {
            metric = parseTimeToSeconds(raw);  // lower better
          }
        }

        // If metric couldn't be parsed, treat as worst too
        scored.push({
          entryId: r.entryId,
          raw,
          isWorst: isSpecialWorst || metric == null,
          metric
        });
      }

      if (!scored.length) return new Map();

      // Sort best -> worst
      scored.sort((a, b) => {
        // worst always last
        if (a.isWorst && !b.isWorst) return 1;
        if (!a.isWorst && b.isWorst) return -1;

        // both worst => tied
        if (a.isWorst && b.isWorst) return 0;

        // both non-worst: compare metric
        if (discipline === "fence") {
          // higher victories better
          if (b.metric !== a.metric) return b.metric - a.metric;
          return 0;
        } else {
          // lower time better
          if (a.metric !== b.metric) return a.metric - b.metric;
          return 0;
        }
      });

      // Assign 1,1,3... ranking
      const placeByEntry = new Map();
      let lastKey = null;
      let lastPlace = 0;

      for (let i = 0; i < scored.length; i++) {
        const s = scored[i];

        // key for tie grouping
        // - worst group all tied together
        // - otherwise metric determines ties
        let key;
        if (s.isWorst) {
          key = "WORST";
        } else {
          key = String(s.metric);
        }

        let place;
        if (i === 0) {
          place = 1;
        } else if (key === lastKey) {
          place = lastPlace;
        } else {
          place = i + 1;
        }

        placeByEntry.set(s.entryId, place);
        lastKey = key;
        lastPlace = place;
      }

      return placeByEntry;
    }

    function buildDivisionRows(division) {
      const entries = division.entries || [];
      const rows = entries.map(e => {
        const a = e.athletes || e.athlete || {};
        const resArr = e.results || [];

        const byDisc = {
          fence: { raw: "", pts: null },
          swim: { raw: "", pts: null },
          obstacle: { raw: "", pts: null },
          laser: { raw: "", pts: null }
        };

        resArr.forEach(r => {
          if (!r || !r.discipline) return;
          const key = r.discipline;
          if (!byDisc[key]) return;

          byDisc[key] = {
            raw: r.raw_value || "",
            pts: (typeof r.points === "number")
              ? r.points
              : (r.points == null ? null : Number(r.points))
          };
        });

        const total = ["fence", "swim", "obstacle", "laser"].reduce((sum, d) => {
          const val = byDisc[d].pts;
          return sum + (typeof val === "number" ? val : 0);
        }, 0);

        const laserPts = byDisc.laser.pts;
        const hasLaser = typeof laserPts === "number";

        const first = a.first_name || "";
        const last = a.last_name || "";
        const name = (first + " " + last).trim();

        return {
          entryId: e.id,
          name,
          noc: a.noc || "",
          fence: byDisc.fence,
          swim: byDisc.swim,
          obstacle: byDisc.obstacle,
          laser: byDisc.laser,
          total,
          handicap: e.handicap,
          tieBreak: e.tie_break_order,
          hasLaser
        };
      });

      // Post-laser mode if at least one athlete has laser points saved
      const divisionHasLaser = rows.some(r => r.hasLaser);

      // Sort totals desc; if post-laser and both have laser, use tieBreak asc (nulls last); then name
      rows.sort((a, b) => {
        if (b.total !== a.total) return b.total - a.total;

        if (divisionHasLaser && a.hasLaser && b.hasLaser) {
          const aTie = (a.tieBreak == null) ? Number.POSITIVE_INFINITY : a.tieBreak;
          const bTie = (b.tieBreak == null) ? Number.POSITIVE_INFINITY : b.tieBreak;
          if (aTie !== bTie) return aTie - bTie;
        }

        return a.name.localeCompare(b.name);
      });

      rows._divisionHasLaser = divisionHasLaser;
      return rows;
    }

    function renderDivisionJumpButtons(competition) {
      const divisions = (competition.divisions || [])
        .slice()
        .sort((a, b) => {
          const ao = a.order_index ?? 0;
          const bo = b.order_index ?? 0;
          if (ao !== bo) return ao - bo;
          return (a.name || "").localeCompare(b.name || "");
        });

      if (!divisions.length) {
        divisionJumpContainer.innerHTML = "";
        return;
      }

      divisionJumpContainer.innerHTML = divisions.map(d => {
        const label = d.name || "Division";
        return `
          <button
            type="button"
            class="division-jump-btn"
            onclick="scrollToDivision('division-${d.id}')"
          >
            ${label}
          </button>
        `;
      }).join("");
    }

    function renderDisciplineCell(raw, pts, place) {
      const rawTrim = (raw || "").trim();
      const showPlace = !!rawTrim && (place != null);

      const top = rawTrim
        ? `${rawTrim}${showPlace ? ` (${place})` : ""}`
        : "";

      const bottom = (typeof pts === "number") ? String(pts) : "";

      // If absolutely nothing, return blank
      if (!top && !bottom) return "";

      return `
        <div class="disc-wrap">
          <div class="disc-top">${top}</div>
          <div class="disc-bottom">${bottom}</div>
        </div>
      `;
    }

    function renderCompetitionLeaderboards(competition) {
      activeCompetition = competition || null;

      if (!competition) {
        leaderboardContainer.innerHTML = "";
        divisionJumpContainer.innerHTML = "";
        competitionMeta.innerHTML = "";
        printBtn.disabled = true;
        printBtn.style.display = "none";
        return;
      }

      const statusHtml = formatStatusPill(competition.status);
      const range = formatDateRange(competition.start_date, competition.end_date);
      const location = competition.location || "";

      competitionMeta.innerHTML = `
        ${statusHtml}
        ${location ? `<span class="pill">${location}</span>` : ""}
        ${range ? `<span class="pill">${range}</span>` : ""}
        ${competition.status === "finished" ? `<span class="pill">Finished</span>` : ""}
      `;

      renderDivisionJumpButtons(competition);

      const divisions = (competition.divisions || [])
        .slice()
        .sort((a, b) => {
          const ao = a.order_index ?? 0;
          const bo = b.order_index ?? 0;
          if (ao !== bo) return ao - bo;
          return (a.name || "").localeCompare(b.name || "");
        });

      if (!divisions.length) {
        leaderboardContainer.innerHTML = `
          <div class="card">
            <p class="note">No divisions have been added for this competition yet.</p>
          </div>
        `;
        printBtn.disabled = true;
        printBtn.style.display = "none";
        return;
      }

      const html = divisions.map(div => {
        const rows = buildDivisionRows(div);
        const divisionHasLaser = !!rows._divisionHasLaser;

        // Discipline places (based on raw)
        const fencePlaces = computeDisciplinePlaces(rows, "fence");
        const swimPlaces = computeDisciplinePlaces(rows, "swim");
        const obstaclePlaces = computeDisciplinePlaces(rows, "obstacle");
        const laserPlaces = computeDisciplinePlaces(rows, "laser");

        const tags = [];
        if (div.age_group) tags.push(div.age_group);
        if (div.gender) tags.push(div.gender);

        if (!rows.length) {
          return `
            <div class="card" id="division-${div.id}">
              <div class="division-header">
                <h2>${div.name || "Division"}</h2>
                <div class="division-tags">
                  ${tags.map(t => `<span class="pill">${t}</span>`).join(" ")}
                </div>
              </div>
              <p class="note">No athletes or results yet for this division.</p>
            </div>
          `;
        }

        // Place rules for overall division:
        // - Pre-laser: ties shown as 1,1,1,4 based on total points
        // - Post-laser: unique places 1..N based on sorted order (tieBreak resolves close finishes)
        let lastPoints = null;
        let lastPlace = 0;

        const body = rows.map((r, idx) => {
          let place;

          if (divisionHasLaser) {
            place = idx + 1;
          } else {
            if (idx === 0) place = 1;
            else if (r.total === lastPoints) place = lastPlace;
            else place = idx + 1;

            lastPoints = r.total;
            lastPlace = place;
          }

          return `
            <tr>
              <td class="rank-cell">${place}</td>
              <td>
                <div class="name-cell">${r.name || ""}</div>
                <div class="noc-cell">${r.noc || ""}</div>
              </td>

              <td class="disc-cell">
                ${renderDisciplineCell(r.fence.raw, r.fence.pts, fencePlaces.get(r.entryId) ?? null)}
              </td>
              <td class="disc-cell">
                ${renderDisciplineCell(r.swim.raw, r.swim.pts, swimPlaces.get(r.entryId) ?? null)}
              </td>
              <td class="disc-cell">
                ${renderDisciplineCell(r.obstacle.raw, r.obstacle.pts, obstaclePlaces.get(r.entryId) ?? null)}
              </td>
              <td class="disc-cell">
                ${renderDisciplineCell(r.laser.raw, r.laser.pts, laserPlaces.get(r.entryId) ?? null)}
              </td>

              <td style="text-align:right;">${r.total || 0}</td>
              <td class="handicap-cell" style="text-align:right;">${formatHandicap(r.handicap)}</td>
            </tr>
          `;
        }).join("");

        return `
          <div class="card" id="division-${div.id}">
            <div class="division-header">
              <h2>${div.name || "Division"}</h2>
              <div class="division-tags">
                ${tags.map(t => `<span class="pill">${t}</span>`).join(" ")}
              </div>
            </div>
            <table>
              <thead>
                <tr>
                  <th>Place</th>
                  <th>Athlete</th>
                  <th class="disc-head">Fence</th>
                  <th class="disc-head">Swim</th>
                  <th class="disc-head">Obstacle</th>
                  <th class="disc-head">Laser Run</th>
                  <th>Total</th>
                  <th>Handicap<br/><span style="font-size:0.7rem;">m:ss</span></th>
                </tr>
              </thead>
              <tbody>${body}</tbody>
            </table>
          </div>
        `;
      }).join("");

      leaderboardContainer.innerHTML = html;

      printBtn.disabled = false;
      printBtn.style.display = "inline-block";
    }

    async function loadCompetitions() {
      setCompetitionMessage("Loading competitions...", "info");

      const { data, error } = await supabase
        .from("competitions")
        .select(`
          id,
          name,
          location,
          start_date,
          end_date,
          status,
          divisions (
            id,
            name,
            age_group,
            gender,
            order_index,
            entries (
              id,
              handicap,
              tie_break_order,
              athletes (
                first_name,
                last_name,
                noc
              ),
              results (
                discipline,
                raw_value,
                points
              )
            )
          )
        `)
        .in("status", ["live", "finished"])
        .order("start_date", { ascending: false });

      if (error) {
        console.error(error);
        setCompetitionMessage("Failed to load competitions.", "error");
        currentSelect.innerHTML = '<option value="">Select a live competition</option>';
        pastSelect.innerHTML = '<option value="">Select a finished competition</option>';
        renderCompetitionLeaderboards(null);
        return;
      }

      const all = data || [];
      liveCompetitions = all.filter(c => (c.status || "").toLowerCase() === "live");
      finishedCompetitions = all.filter(c => (c.status || "").toLowerCase() === "finished");

      // Populate selects (NO auto selection)
      currentSelect.innerHTML = `
        <option value="">Select a live competition</option>
        ${liveCompetitions.map(c => `<option value="${c.id}">${c.name}</option>`).join("")}
      `;
      pastSelect.innerHTML = `
        <option value="">Select a finished competition</option>
        ${finishedCompetitions.map(c => `<option value="${c.id}">${c.name}</option>`).join("")}
      `;

      setCompetitionMessage("Select a Current or Past competition to view results.", "info");
      renderCompetitionLeaderboards(null);
    }

    function clearDisplay() {
      competitionMeta.innerHTML = "";
      divisionJumpContainer.innerHTML = "";
      leaderboardContainer.innerHTML = "";
      printBtn.disabled = true;
      printBtn.style.display = "none";
      activeCompetition = null;
    }

    currentSelect.addEventListener("change", () => {
      const id = currentSelect.value;

      // If selecting live, clear past selection
      if (id) pastSelect.value = "";

      clearDisplay();

      if (!id) {
        setCompetitionMessage("Select a Current or Past competition to view results.", "info");
        return;
      }

      const comp = liveCompetitions.find(c => String(c.id) === String(id));
      if (!comp) return;

      setCompetitionMessage("");
      renderCompetitionLeaderboards(comp);
    });

    pastSelect.addEventListener("change", () => {
      const id = pastSelect.value;

      // If selecting finished, clear current selection
      if (id) currentSelect.value = "";

      clearDisplay();

      if (!id) {
        setCompetitionMessage("Select a Current or Past competition to view results.", "info");
        return;
      }

      const comp = finishedCompetitions.find(c => String(c.id) === String(id));
      if (!comp) return;

      setCompetitionMessage("");
      renderCompetitionLeaderboards(comp);
    });

    printBtn.addEventListener("click", () => window.print());

    function scrollToDivision(targetId) {
      const el = document.getElementById(targetId);
      if (!el) return;
      el.scrollIntoView({ behavior: "smooth", block: "start" });
    }
    window.scrollToDivision = scrollToDivision;

    (async function init() {
      await loadCompetitions();
    })();
  </script>
</body>
</html>
